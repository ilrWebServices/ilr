<?php

/**
 * @file
 * Contains collection_item_path.module.
 */

use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\ContentEntityInterface;

/**
 * Implements hook_entity_base_field_info().
 *
 * Adds the `path` base field definition to collection items.
 */
function collection_item_path_entity_base_field_info(EntityTypeInterface $entity_type) {
  if ($entity_type->id() === 'collection_item') {
    $fields['path'] = BaseFieldDefinition::create('path')
      ->setLabel(t('URL alias'))
      ->setDescription(t('The collection item URL alias.'))
      ->setTranslatable(TRUE)
      ->setDisplayOptions('form', [
        'type' => 'path',
        'weight' => 12,
      ])
      ->setDisplayConfigurable('form', TRUE)
      ->setComputed(TRUE);

    return $fields;
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Modifies the url for collection items. Since we "cross-post" items, this
 * allows a content admin to visit the cross post itself. Eventually, we might
 * add something like `$row['#entity'] = $entity` to the
 * CollectionItemListBuilder to make this simpler.
 */
function collection_item_path_form_collection_item_list_alter(&$form, FormStateInterface $form_state, $form_id) {
  $entity_type_manager = \Drupal::service('entity_type.manager');
  $collection_item_storage = $entity_type_manager->getStorage('collection_item');

  foreach ($form['entities'] as $key => &$row) {
    if (!is_numeric($key) || !is_array($row)) {
      continue;
    }

    if ($collection_item = $collection_item_storage->load($key)) {

      if (!$collection_item->item->entity instanceof ContentEntityInterface) {
        continue;
      }

      $row['item'] = [
        '#type' => 'link',
        '#title' => $collection_item->item->entity->label(),
        '#url' => $collection_item->toURL(),
      ];
    }
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * Update the tab title when viewing a collection item, to make it easier to
 * distinguish between editing the content of the item, and editin the item
 * itself. @see collection_item_path.links.task.yml
 */

function collection_item_path_menu_local_tasks_alter(&$data, $route_name) {
  if ($route_name !== 'entity.collection_item.canonical') {
    return;
  }

  if (isset($data['tabs'][0]['entity.collection_item.edit_form'])) {
    $data['tabs'][0]['entity.collection_item.edit_form']['#link']['title'] = t('Edit item');
  }
}

/**
 * Implements hook_node_view_alter().
 *
 * Sets the collection_item_url for non-canonical collection items.
 */
function collection_item_path_node_view_alter(array &$build) {
  if (isset($build['#collection_item']) && !$build['#collection_item']->isCanonical()) {
    $build['#node']->collection_item_url = $build['#collection_item']->toUrl();
  }
}

/**
 * Implements hook_taxonomy_term_view_alter().
 *
 * Sets the collection_item_url for extra fields rendered. Note that this looks
 * for a `collection_item` key in the render array. We may want to improve this,
 * possibly by looking for the `#collection_listing` key for all rendered
 * fields.
 */
function collection_item_path_taxonomy_term_view_alter(array &$build) {
  $rendered_collection_items = preg_grep('/^collection_item/', array_keys($build));

  if (empty($rendered_collection_items)) {
    return;
  }

  $collection_item_list = &$build[current($rendered_collection_items)];

  if (!isset($collection_item_list['#collection_listing'])) {
    return;
  }

  foreach ($collection_item_list['#items'] as &$item) {
    if ($item['#collection_item']->isCanonical()) {
      continue;
    }
    if (isset($item['#node'])) {
      $item['#node']->collection_item_url = $item['#collection_item']->toUrl();
    }
  }
}

/**
 * Link to the collection_item_url if it has been set.
 */
function collection_item_path_preprocess_node(&$variables) {
  if ($collection_item_url = $variables['node']->collection_item_url) {
    $variables['url'] = $collection_item_url;
  }
}
